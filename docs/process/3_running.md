# 迭代
!!! quote

    "Sometimes you gotta RUN before you can WALK"
    --- Tony Stark 


## 课程
> 以教为学 --> 教半年前的自己

- 所谓 `The Feynman Technique Model` [^1][^2] 是这么宣称的:
    + 具体知识学习时, 最深刻最有较的学习方式是这样来
    + 先自行根据领域问题完成独立推导, 重新自主发现其中所有关键公式
    + 然后再和教科书对比, 明确自己答案正确
    + 再将推导过程用自己的方式/语言教给朋友/同学们
    + 如果他们听的懂, 这才能证明:
        * 自己真正掌握了目标领域核心知识
- 很明确, 这是真正超级学霸的方式
- 我们只是普通人, 想在工作/生存之余快速有条件的掌握有兴趣的知识/技能
- 那么, 就只能对 `The Feynman Technique Model` 进行简化:

## 任务
> 用开发任务来替代无目标自学

- 蠎营 课程以一系列核心述求不变, 持续迭代为关联的任务组成
- 任务 即开发阶段目标/版本/需求集:
    + 有明确的实用要求
    + 有具体的形态参考
    + 而且, 重点是 -> 绝对没有正确答案
- 这样就等于解放了自学时的主要压抑
- 我们无论进行什么样的探索都是正义的
- 只是这种探索是有共同规约的:
    + 在规定时间里, 一般是一周以内
    + 完成最小可用功能集, 以便能拿出来作为下一个周任务的基础
- 这样, 面对领域知识:
    + 我们永远有一个稳定可用作品来证明当前自学进展
    + 同时, 每天自学目标从模糊的掌握变成要完成某某功能
    + 从而将无限探索的精力和担心
    + 变成具体问题的逐一解决
- 成就感 几乎可以稳定的每 42 分钟就撞到一次
    + 无论成功还是失败
    + 都能明确的知道自己知道了什么, 或是不知道什么
    + 从以往几年都不知道自己学了什么, 能作什么是迷妄状态
    + 彻底解放出来...
- 也令自己随时可以沉浸入以任务为线索的自学中


## 交流
> 独乐乐不如众乐乐

- 当然, 对于从来没有编程体验的学员而言
    + 任何一行代码都充满了未知和不可知性
- 所以, 独立探索和开放讨论必须相辅相成
    + 否则, 就只能退化回传统学校提供标准问题和答案对的机械记忆式课程了
- 所以, 蠎营 一开始就在标准软件工程环境中
    + 通过标准工程化交流渠道
    + 以代码+文字为界面
    + 将每一个困惑变成可讨论的技术问题
    + 并在课程内公开, 全程随时随地讨论
- 那么, 无论自学姿势和速度如何
    + 都有一个标准化界面和形式可以加速指定和讨论
    + 大家不用担心表达水平或是对方是否有空
    + 嘦按照格式发布出来, 无论助教/学员/讲师/...
    + 任何嘦知道并有空的成员, 都可以从桌面/手机/平板/Slack/...自由回复
- 最终, 课程就变成了一个主题自学型社区
    + 每个人都在产生新经验/知识
    + 并及时共享回社区
    + 在社区中持续沉淀并回响
    + 在每周的课程周刊中重点报道...
- 编程, 就是交流
    + 人和人的交流是第一位的
    + 人和代码的交流是第0位的
    + 但是, 最终还得是人和人的交流
        * 代码形成的软件
        * 只是替代人来加速/普遍化而已


## refer


[^1]: [The Feynman Technique Model — MATTYFORD](https://mattyford.com/blog/2014/1/23/the-feynman-technique-model)

[^2]: [费曼学习法凭什么号称终极学习法?_36氪](https://36kr.com/p/5099728.html)
